#' @title Extract Residuals from \code{maxlogL} model.
#'
#' @author Jaime Mosquera Guti√©rrez, \email{jmosquerag@unal.edu.co}
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' \code{residuals.maxlogL} is the \code{maxlogLreg} specific method for the
#' generic function residuals which extracts the residuals from a fitted model.
#'
#' @aliases residuals.maxlogL
#'
#' @param object an object of \code{\link{maxlogL}} class obtained by fitting a
#'               model with \code{\link{maxlogLreg}}.
#' @param parameter a character which specifies residuals for a specific parameter.
#' @param type a character with the type of residuals to be computed.
#'             The default value is \code{type = "rqres"}, which is used to
#'             compute the normalized randomized quantile residuals.
#' @param routine a character specifying the integration routine.
#'                \code{integrate} and \code{gauss_quad} are available. Custom
#'                routines can be defined but they must be compatible with the
#'                \code{\link{integration}} API.
#' @param ... further arguments for the integration routine.
#'
#' @details
#' For \code{type = "deviance"}, the residuals are computed using the following
#' expression
#'
#' \deqn{r^D_i = \mbox{sign}(y_i - \hat{\mu}_i) d_i^{1/2},}
#'
#' where \eqn{d_i} is the residual deviance of each data point. In this context,
#' \eqn{\hat{\mu}} is the estimated mean, computed as the expected value using
#' the estimated parameters of a fitted \code{maxlogLreg} model.
#'
#' On the other hand, for \code{type = "response"} the computation is simpler
#'
#' \deqn{r^R_i = (y_i - \hat{\mu}_i).}
#'
#' @return a vector with the specified residuals of a \code{maxlogLreg} model.
#'
#' @method residuals maxlogL
#' @export
residuals.maxlogL <- function(
    object,
    parameter = NULL,
    type = "rqres",
    routine,
    ...
){
  available_residuals <- c(
    "rqres",
    "response",
    "cox-snell",
    "martingale",
    "censored-deviance"
  )

  type <- match.arg(type, choices = available_residuals)

  if ( is.null(parameter) ) parameter <- object$outputs$par_names[1]
  parameter <- match.arg(parameter, choices = object$outputs$par_names)

  y <- object$outputs$response
  support <- object$inputs$support
  dist <- deparse(object$inputs$y_dist[[3]])
  cens <- object$inputs$cens

  if ( is.null(support) & type %in% available_residuals ){
    stop(paste0(type, " residuals cannot be computed if a support is",
                "not defined. Please, refit your 'maxlogLreg' model",
                "specifying the 'support' argument."))
  }

  right_censored_data <- check_right_censorship(
    cens_matrix = cens, type = type
  )

  if (right_censored_data){
    # if ( is.Surv(object$inputs$y_dist) ){
    cumHaz <- cum_hazard_maxlogL(object)
    delta <- cens[, 2]

    # Martingale for right censored data
    mres <- delta - cumHaz

    if (type == "cox-snell") resid <- cumHaz

    if (type == 'martingale') resid <- mres

    if (type == 'censored-deviance'){
      deviance_i <- -2 * ( mres + delta * log(delta - mres) )
      resid <- sign(mres) * sqrt(deviance_i)
    }
    # }
  }

  if (type == "response"){
    if (missing(routine)) routine <- "monte-carlo"
    mean <- expected_value.maxlogL(
      object = object,
      routine = routine,
      n = 1e6
    )
    resid <- y - mean
  }

  if (type == "rqres"){
    distr <- object$inputs$distr
    cum_fun <- paste0('p', substring(distr, 2))
    fitted_parameters <- object$outputs$fitted.values
    Fyi <- do.call(
      what = cum_fun,
      args = c(list(q = y, lower.tail = TRUE, log.p = FALSE), fitted_parameters)
    )
    resid <- qnorm(p = Fyi, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
  }

  names(resid) <- 1:length(y)
  return(resid)
}

check_right_censorship <- function(cens_matrix, type){
  if ( sum(cens_matrix[, 2]) > 0 ){
    stop(
      paste0(
        "'", type, "'",
        " residuals are not available for left censored data. Please, ",
        "compute randomized quantile residuals or raw residuals, which are ",
        "available for any censorship type. Just set residuals = 'rqres' or ",
        "residuals = 'response' respectively.")
    )
  }
  if ( sum(cens_matrix[, 2]) > 0 ){
    return(TRUE)
  } else {
    return(FALSE)
  }
}
#==============================================================================
# Deviance for each data point ------------------------------------------------
#==============================================================================
# Deviance of each data point for \code{maxlogLreg} outputs
# This function computes the deviance for each data point from the
# response variable given a fitted model.
#
# param object an object of \code{maxlogL} class generated by
#       \code{\link{maxlogLreg}} function.
#
# details
# The function requires a fitted model with \code{maxlogLreg}.
#
# return
# This function returns a list with the following elements:
# \enumerate{
#    \item \code{deviance_i}: the contribution of each value of the
#    response variable in the data set to the deviance.
#    \item \code{proposed_deviance_i}: log-likelihood of data given the fitted
#    model in \code{object} argument.
#    \item \code{saturated_deviance_i}. log-likelihood of data given the
#    saturated model.
# }
dev.resids <- function(object){
  if (object$outputs$type != "maxlogLreg")
    stop(paste("'dev.resids()' method only useful for models with ",
               "covariates. \n Use 'maxlogLreg' in order to ",
               "take advantage of this method."))
  # Details of Proposed model
  distr <- object$inputs$distr
  fitted.values0 <- object$outputs$fitted.values
  y <- object$outputs$response
  loglik0_i <- do.call(what = distr,
                       args = c(list(x = y, log = TRUE), fitted.values0))

  # Saturated model
  saturated_model <- saturated_maxlogL(object)
  fitted.valuesS <- saturated_model$outputs$fitted.values
  loglikS_i <- do.call(what = distr,
                       args = c(list(x = y, log = TRUE), fitted.valuesS))
  output <- list(deviance_i = 2 * (loglikS_i - loglik0_i),
                 proposed_deviance_i = loglik0_i,
                 saturated_deviance_i = loglikS_i)
  return(output)
}
#==============================================================================
# Computation of cumulative for a fitted model --------------------------------
#==============================================================================
cum_hazard_maxlogL <- function(object, routine, ...){
  distr <- object$inputs$distr
  support <- object$inputs$support

  Hfun <- cum_hazard_fun(
    distr = distr,
    support = support,
    method = "log_sf"
  )

  parameters <- object$outputs$fitted.values
  par_names <- names(parameters)
  parameters <- matrix(unlist(parameters), nrow = object$outputs$n)

  response <- object$outputs$response

  inputs_matrix <- cbind(response, parameters)
  colnames(inputs_matrix) <- c("x", par_names)

  Hf_i <- function(x){
    args <- sapply(X = x, FUN = function(x) x, simplify = FALSE)
    cum_haz <- do.call(
      what = Hfun,
      args = args
    )
    return(cum_haz)
  }

  result <- apply(
    inputs_matrix,
    MARGIN = 1,
    FUN = Hf_i
  )
  return(result)
  # integrand <- hazard_fun(distr, support)
  #
  # if ( missing(routine) ){
  #   if (support$type == 'continuous'){
  #     routine <- 'integrate'
  #   } else if (support$type == 'discrete'){
  #     routine <- 'summate'
  #   }
  # }
  # haz_computation <- function(x)
  #   do.call(what = 'integration',
  #           args = c(list(fun = integrand, lower = support$interval[1],
  #                         upper = support$interval[2],
  #                         routine = routine, ...), x))
  # result <- apply(parameters, MARGIN = 1, haz_computation)
}
